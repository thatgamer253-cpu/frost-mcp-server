# ðŸ“¦ Consolidated Package: aura-nexus

*Generated by Overlord on 2026-02-15 13:50:57*

## ðŸŽ¯ Project Overview

Aura-Nexus is a modular, asynchronous Python-based Autonomous Task Orchestrator designed for users who need to decompose high-level goals into executable sub-tasks using dynamic tool-calling. It utilizes a Directed Acyclic Graph (DAG) architecture for efficient task management and incorporates technologies such as aiohttp, fastapi, and asyncio. To install and run Aura-Nexus, ensure all dependencies are met and execute the command `python app.py`.

## ðŸ”§ Environment Setup

```bash
mkdir aura-nexus && cd aura-nexus
python -m venv venv
# Windows: venv\Scripts\activate  |  Unix: source venv/bin/activate
pip install -r requirements.txt
python app.py
```

## ðŸ“‹ File Manifest

| File | Lines | Chars | Purpose |
|------|------:|------:|---------|
| `app.py` | 27 | 722 | py source file |
| `core/__init__.py` | 11 | 250 | py source file |
| `core/base_tool.py` | 36 | 1,273 | py source file |
| `core/task_manager.py` | 46 | 1,985 | py source file |
| `core/plugin_loader.py` | 42 | 1,864 | py source file |
| `core/state_manager.py` | 46 | 1,936 | py source file |
| `core/error_handler.py` | 62 | 2,060 | py source file |
| `tools/__init__.py` | 40 | 1,348 | Initialize logging for the tools module |
| `config.yaml` | 24 | 458 | Configuration settings for the application |
| `README.md` | 11 | 318 | md source file |

**Total: 10 files, 12,214 characters**

## ðŸ’» Source Code

### `app.py`
```python
import logging
import yaml

def initialize_logging():
    logging_config = {
        'level': logging.INFO,
        'format': '%(asctime)s - %(levelname)s - %(message)s',
    }
    logging.basicConfig(**logging_config)
    logging.info("Logging initialized.")

def main():
    initialize_logging()
    
    try:
        logging.info("Starting system initialization.")
        
        # Initialize core components
        with open('config.yaml', 'r') as config_file:
            config = yaml.safe_load(config_file)
        db_path = config.get('database', {})
        # Continue with the rest of the logic
    except Exception as e:
        logging.error(f"An error occurred: {e}")

if __name__ == "__main__":
    main()
```

### `core/__init__.py`
```python
from .task_manager import TaskManager
from .plugin_loader import PluginLoader
from .state_manager import StateManager
from .error_handler import ErrorHandler

__all__ = [
    "TaskManager",
    "PluginLoader",
    "StateManager",
    "ErrorHandler"
]
```

### `core/base_tool.py`
```python
class BaseTool:
    """
    BaseTool is an abstract class that all plugins must inherit from.
    It defines the basic interface and lifecycle for plugins.
    """

    def __init__(self, name, version):
        """
        Initialize the BaseTool with a name and version.

        :param name: The name of the tool.
        :param version: The version of the tool.
        """
        self.name = name
        self.version = version

    def initialize(self):
        """
        Initialize the tool. This method should be overridden by subclasses.
        """
        raise NotImplementedError("The initialize method must be overridden by the subclass.")

    def execute(self, *args, **kwargs):
        """
        Execute the tool's main functionality. This method should be overridden by subclasses.

        :param args: Positional arguments for execution.
        :param kwargs: Keyword arguments for execution.
        """
        raise NotImplementedError("The execute method must be overridden by the subclass.")

    def shutdown(self):
        """
        Shutdown the tool and perform any necessary cleanup. This method should be overridden by subclasses.
        """
        raise NotImplementedError("The shutdown method must be overridden by the subclass.")
```

### `core/task_manager.py`
```python
from collections import defaultdict
from core.base_tool import BaseTool
import logging

class TaskManager:
    def __init__(self, state_manager, plugin_loader):
        self.state_manager = state_manager
        self.plugin_loader = plugin_loader
        self.tasks = defaultdict(list)
        self.logger = logging.getLogger(__name__)

    def add_task(self, task_name, task_instance):
        if not isinstance(task_instance, BaseTool):
            raise ValueError("Task instance must be of type BaseTool")
        self.tasks[task_name].append(task_instance)
        self.logger.info(f"Task {task_name} added.")

    def execute_tasks(self):
        try:
            self.logger.info("Executing tasks in DAG order.")
            for task_name, task_list in self.tasks.items():
                self.logger.info(f"Executing task group: {task_name}")
                for task in task_list:
                    self.logger.info(f"Initializing task: {task}")
                    task.initialize()
                    self.logger.info(f"Executing task: {task}")
                    task.execute()
                    self.logger.info(f"Shutting down task: {task}")
                    task.shutdown()
            self.logger.info("All tasks executed successfully.")
        except Exception as e:
            self.logger.error("Error occurred during task execution.", exc_info=True)
            raise

    def load_tasks_from_plugins(self):
        try:
            self.logger.info("Loading tasks from plugins.")
            plugins = self.plugin_loader.load_plugins()
            for plugin in plugins:
                task_name = plugin.get_task_name()
                task_instance = plugin.get_task_instance()
                self.add_task(task_name, task_instance)
            self.logger.info("Tasks loaded from plugins successfully.")
        except Exception as e:
            self.logger.error("Error occurred while loading tasks from plugins.", exc_info=True)
            raise
```

### `core/plugin_loader.py`
```python
import os
import importlib.util
import logging
from core.base_tool import BaseTool

class PluginLoader:
    def __init__(self, plugins_directory):
        self.plugins_directory = plugins_directory
        self.logger = logging.getLogger(__name__)

    def load_plugins(self):
        plugins = []
        try:
            self.logger.info(f"Loading plugins from directory: {self.plugins_directory}")
            for filename in os.listdir(self.plugins_directory):
                if filename.endswith('.py') and not filename.startswith('__'):
                    plugin_path = os.path.join(self.plugins_directory, filename)
                    plugin = self._load_plugin(plugin_path)
                    if plugin:
                        plugins.append(plugin)
            self.logger.info("Plugins loaded successfully.")
        except Exception as e:
            self.logger.error("Error occurred while loading plugins.", exc_info=True)
            raise
        return plugins

    def _load_plugin(self, plugin_path):
        try:
            self.logger.info(f"Loading plugin from path: {plugin_path}")
            module_name = os.path.splitext(os.path.basename(plugin_path))[0]
            spec = importlib.util.spec_from_file_location(module_name, plugin_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            for attribute_name in dir(module):
                attribute = getattr(module, attribute_name)
                if isinstance(attribute, type) and issubclass(attribute, BaseTool) and attribute is not BaseTool:
                    self.logger.info(f"Plugin {attribute_name} loaded successfully.")
                    return attribute()
        except Exception as e:
            self.logger.error(f"Error loading plugin from {plugin_path}", exc_info=True)
            return None
```

### `core/state_manager.py`
```python
import sqlite3
from contextlib import closing

class StateManager:
    def __init__(self, db_path, logger):
        self.db_path = db_path
        self.logger = logger

    def set_task_status(self, task_name, status):
        try:
            with closing(sqlite3.connect(self.db_path)) as conn:
                with conn:
                    conn.execute('''
                        INSERT INTO task_status (task_name, status) VALUES (?, ?)
                        ON CONFLICT(task_name) DO UPDATE SET status=excluded.status
                    ''', (task_name, status))
            self.logger.info(f"Task '{task_name}' status set to '{status}'.")
        except sqlite3.Error as e:
            self.logger.error(f"Failed to set status for task '{task_name}'.", exc_info=True)
            raise

    def get_task_status(self, task_name):
        try:
            with closing(sqlite3.connect(self.db_path)) as conn:
                cursor = conn.execute('''
                    SELECT status FROM task_status WHERE task_name = ?
                ''', (task_name,))
                result = cursor.fetchone()
                status = result[0] if result else None
            self.logger.info(f"Retrieved status for task '{task_name}': '{status}'.")
            return status
        except sqlite3.Error as e:
            self.logger.error(f"Failed to get status for task '{task_name}'.", exc_info=True)
            raise

    def delete_task_status(self, task_name):
        try:
            with closing(sqlite3.connect(self.db_path)) as conn:
                with conn:
                    conn.execute('''
                        DELETE FROM task_status WHERE task_name = ?
                    ''', (task_name,))
            self.logger.info(f"Task '{task_name}' status deleted.")
        except sqlite3.Error as e:
            self.logger.error(f"Failed to delete status for task '{task_name}'.", exc_info=True)
            raise
```

### `core/error_handler.py`
```python
import logging
import traceback

class ErrorHandler:
    @staticmethod
    def handle_exception(exception):
        """
        Handle exceptions by logging the error details and attempting recovery if possible.

        :param exception: The exception to handle.
        """
        logger = logging.getLogger(__name__)
        logger.error("An exception occurred: %s", str(exception))
        logger.debug("Exception traceback: %s", traceback.format_exc())

        # Attempt to recover from specific known exceptions
        if isinstance(exception, FileNotFoundError):
            ErrorHandler._handle_file_not_found(exception)
        elif isinstance(exception, ConnectionError):
            ErrorHandler._handle_connection_error(exception)
        else:
            logger.error("Unhandled exception type: %s", type(exception).__name__)

    @staticmethod
    def _handle_file_not_found(exception):
        """
        Handle FileNotFoundError by logging and suggesting corrective actions.

        :param exception: The FileNotFoundError to handle.
        """
        logger = logging.getLogger(__name__)
        logger.warning("File not found: %s. Please check the file path.", exception.filename)

    @staticmethod
    def _handle_connection_error(exception):
        """
        Handle ConnectionError by logging and suggesting corrective actions.

        :param exception: The ConnectionError to handle.
        """
        logger = logging.getLogger(__name__)
        logger.warning("Connection error occurred. Please check your network settings and try again.")
        
    @staticmethod
    def log_warning(message):
        """
        Log a warning message.

        :param message: The warning message to log.
        """
        logger = logging.getLogger(__name__)
        logger.warning(message)

    @staticmethod
    def log_info(message):
        """
        Log an informational message.

        :param message: The informational message to log.
        """
        logger = logging.getLogger(__name__)
        logger.info(message)
```

### `tools/__init__.py`
```python
import os
import logging
from .state_manager import StateManager
from .plugin_loader import PluginLoader
from .task_manager import TaskManager
from .error_handler import ErrorHandler

# Initialize logging for the tools module
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Define the directory where plugins are stored
PLUGINS_DIRECTORY = os.path.join(os.path.dirname(__file__), 'plugins')

# Initialize core components
state_manager = StateManager(db_path='path/to/db', logger=logger)
plugin_loader = PluginLoader(plugins_directory=PLUGINS_DIRECTORY)
task_manager = TaskManager(state_manager=state_manager, plugin_loader=plugin_loader)

def initialize_tools():
    """
    Initialize the tools module by loading plugins and preparing tasks.
    """
    try:
        logger.info("Initializing tools module.")
        
        # Load plugins
        plugins = plugin_loader.load_plugins()
        logger.info(f"Loaded {len(plugins)} plugins.")
        
        # Load tasks from plugins
        task_manager.load_tasks_from_plugins()
        logger.info("Tasks loaded from plugins successfully.")
        
    except Exception as e:
        ErrorHandler.handle_exception(e)
        logger.error("An error occurred during tools initialization.", exc_info=True)

# Initialize tools when the module is imported
initialize_tools()
```

### `config.yaml`
```yaml
# Configuration settings for the application

logging:
  level: INFO
  format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
  datefmt: '%Y-%m-%d %H:%M:%S'

plugins:
  directory: 'plugins'
  auto_load: true

task_manager:
  max_concurrent_tasks: 5
  retry_on_failure: true
  retry_attempts: 3
  retry_delay_seconds: 5

error_handling:
  log_traceback: true
  notify_admin: false

state_manager:
  save_interval_seconds: 60
  state_file: 'state.json'
```

### `README.md`
```markdown
graph TD;
    A[Start Application] --> B[Initialize Logging]
    B --> C[Load Plugins]
    C --> D[Add Tasks]
    D --> E[Execute Tasks]
    E --> F{Task Execution Successful?}
    F -- Yes --> G[Update Task Status]
    F -- No --> H[Handle Error]
    G --> I[Shutdown Plugins]
    H --> I
    I --> J[End Application]
```

---
*End of Consolidated Package â€” aura-nexus*