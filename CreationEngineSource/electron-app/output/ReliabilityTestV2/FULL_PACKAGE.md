# ðŸ“¦ Consolidated Package: crypto_portfolio_dashboard

*Generated by Overlord on 2026-02-15 06:00:29*

## ðŸŽ¯ Project Overview

The Crypto Portfolio Dashboard is a native Linux desktop application designed for users to monitor their cryptocurrency portfolio, specifically Bitcoin and Ethereum, in real-time. It is built using Python 3.11+ and PyQt6, featuring live price data retrieval from a cryptocurrency API and portfolio data storage in SQLite. To install and run the application, execute the 'install.sh' script and then launch it using the command 'python3 main.py'.

## ðŸ”§ Environment Setup

```bash
mkdir crypto_portfolio_dashboard && cd crypto_portfolio_dashboard
python -m venv venv
# Windows: venv\Scripts\activate  |  Unix: source venv/bin/activate
pip install -r requirements.txt
python3 main.py
```

## ðŸ“‹ File Manifest

| File | Lines | Chars | Purpose |
|------|------:|------:|---------|
| `main.py` | 15 | 353 | py source file |
| `ui.py` | 46 | 1,848 | py source file |
| `data_manager.py` | 83 | 3,120 | py source file |
| `api_client.py` | 36 | 1,397 | Fetch the current price of a cryptocurrency. |
| `notification_manager.py` | 45 | 1,885 | py source file |
| `exporter.py` | 51 | 2,428 | py source file |
| `requirements.txt` | 4 | 33 | txt source file |
| `README.md` | 2 | 59 | md source file |
| `.env.example` | 18 | 431 | .env.example |
| `install.sh` | 42 | 1,061 | This script installs the necessary system dependencies for t |
| `crypto_portfolio_dashboard.desktop` | 10 | 287 | desktop source file |
| `flatpak_manifest.json` | 70 | 2,393 | json source file |

**Total: 12 files, 15,295 characters**

## ðŸ’» Source Code

### `main.py`
```python
import sys
from PyQt6.QtWidgets import QApplication
from ui import CryptoPortfolioDashboard

def main():
    try:
        app = QApplication(sys.argv)
        window = CryptoPortfolioDashboard()
        window.show()
        sys.exit(app.exec_())
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    main()
```

### `ui.py`
```python
import os
from PyQt6.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QLabel, QPushButton, QDialog, QFormLayout, QLineEdit, QDialogButtonBox
from PyQt6.QtCore import Qt

class CryptoPortfolioDashboard(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Crypto Portfolio Dashboard")
        self.setGeometry(100, 100, 800, 600)
        
        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)
        
        self.layout = QVBoxLayout(self.central_widget)
        
        self.label = QLabel("Welcome to Crypto Portfolio Dashboard", self)
        self.label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(self.label)
        
        self.settings_button = QPushButton("Settings", self)
        self.settings_button.clicked.connect(self.open_settings_dialog)
        self.layout.addWidget(self.settings_button)
        
    def open_settings_dialog(self):
        dialog = SettingsDialog(self)
        dialog.exec()

class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Settings")
        self.setGeometry(150, 150, 400, 300)
        
        self.layout = QFormLayout(self)
        
        self.api_key_input = QLineEdit(self)
        self.api_key_input.setText(os.getenv('API_KEY', ''))
        self.layout.addRow("API Key:", self.api_key_input)
        
        self.api_secret_input = QLineEdit(self)
        self.layout.addRow("API Secret:", self.api_secret_input)
        
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel, self)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.layout.addWidget(self.button_box)
```

### `data_manager.py`
```python
import sqlite3
from sqlite3 import Error
import os

class DataManager:
    def __init__(self, db_file=None):
        self.db_file = db_file or os.getenv('DATABASE_PATH', 'portfolio.db')
        self.connection = None
        self._connect_to_db()

    def _connect_to_db(self):
        """Establish a connection to the SQLite database."""
        try:
            self.connection = sqlite3.connect(self.db_file)
            self._create_tables()
        except Error as e:
            print(f"Error connecting to database: {e}")

    def _create_tables(self):
        """Create necessary tables if they do not exist."""
        try:
            cursor = self.connection.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS portfolio (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    crypto_name TEXT NOT NULL,
                    amount REAL NOT NULL,
                    purchase_price REAL NOT NULL,
                    purchase_date TEXT NOT NULL
                )
            ''')
            self.connection.commit()
        except Error as e:
            print(f"Error creating tables: {e}")

    def add_crypto(self, crypto_name, amount, purchase_price, purchase_date):
        """Add a new cryptocurrency to the portfolio."""
        try:
            cursor = self.connection.cursor()
            cursor.execute('''
                INSERT INTO portfolio (crypto_name, amount, purchase_price, purchase_date)
                VALUES (?, ?, ?, ?)
            ''', (crypto_name, amount, purchase_price, purchase_date))
            self.connection.commit()
        except Error as e:
            print(f"Error adding crypto: {e}")

    def get_portfolio(self):
        """Retrieve the entire cryptocurrency portfolio."""
        try:
            cursor = self.connection.cursor()
            cursor.execute('SELECT * FROM portfolio')
            return cursor.fetchall()
        except Error as e:
            print(f"Error retrieving portfolio: {e}")
            return []

    def update_crypto(self, crypto_id, crypto_name, amount, purchase_price, purchase_date):
        """Update an existing cryptocurrency in the portfolio."""
        try:
            cursor = self.connection.cursor()
            cursor.execute('''
                UPDATE portfolio
                SET crypto_name = ?, amount = ?, purchase_price = ?, purchase_date = ?
                WHERE id = ?
            ''', (crypto_name, amount, purchase_price, purchase_date, crypto_id))
            self.connection.commit()
        except Error as e:
            print(f"Error updating crypto: {e}")

    def delete_crypto(self, crypto_id):
        """Delete a cryptocurrency from the portfolio."""
        try:
            cursor = self.connection.cursor()
            cursor.execute('DELETE FROM portfolio WHERE id = ?', (crypto_id,))
            self.connection.commit()
        except Error as e:
            print(f"Error deleting crypto: {e}")

    def close_connection(self):
        """Close the database connection."""
        if self.connection:
            self.connection.close()
```

### `api_client.py`
```python
import requests

class CoinGeckoAPIClient:
    BASE_URL = "https://api.coingecko.com/api/v3"

    def __init__(self):
        pass

    def get_current_price(self, crypto_id, vs_currency='usd'):
        """Fetch the current price of a cryptocurrency."""
        try:
            response = requests.get(f"{self.BASE_URL}/simple/price", params={
                'ids': crypto_id,
                'vs_currencies': vs_currency
            })
            response.raise_for_status()
            data = response.json()
            return data.get(crypto_id, {}).get(vs_currency)
        except requests.exceptions.RequestException as e:
            print(f"Error fetching current price: {e}")
            return None

    def get_historical_price(self, crypto_id, date, vs_currency='usd'):
        """Fetch the historical price of a cryptocurrency on a specific date."""
        try:
            response = requests.get(f"{self.BASE_URL}/coins/{crypto_id}/history", params={
                'date': date,
                'localization': 'false'
            })
            response.raise_for_status()
            data = response.json()
            market_data = data.get('market_data', {})
            return market_data.get('current_price', {}).get(vs_currency)
        except requests.exceptions.RequestException as e:
            print(f"Error fetching historical price: {e}")
            return None
```

### `notification_manager.py`
```python
from api_client import CoinGeckoAPIClient
import notify2

class NotificationManager:
    def __init__(self, app_name="Crypto Portfolio Dashboard"):
        self.app_name = app_name
        self.api_client = CoinGeckoAPIClient()
        notify2.init(app_name)

    def send_notification(self, title, message):
        """Send a desktop notification."""
        try:
            notification = notify2.Notification(title, message)
            notification.show()
        except Exception as e:
            print(f"Error sending notification: {e}")

    def check_price_change(self, crypto_id, threshold, vs_currency='usd'):
        """Check for significant price changes and notify the user."""
        try:
            current_price = self.api_client.get_current_price(crypto_id, vs_currency)
            if current_price is None:
                print("Failed to retrieve current price.")
                return

            # For demonstration, assume we have a method to get the previous price
            previous_price = self.get_previous_price(crypto_id, vs_currency)
            if previous_price is None:
                print("Failed to retrieve previous price.")
                return

            price_change = ((current_price - previous_price) / previous_price) * 100
            if abs(price_change) >= threshold:
                self.send_notification(
                    f"Significant Price Change for {crypto_id}",
                    f"The price has changed by {price_change:.2f}%"
                )
        except Exception as e:
            print(f"Error checking price change: {e}")

    def get_previous_price(self, crypto_id, vs_currency='usd'):
        """Mock method to get the previous price of a cryptocurrency."""
        # This should be replaced with actual logic to retrieve the previous price
        # For now, return a mock value
        return 100.0
```

### `exporter.py`
```python
import csv
from datetime import datetime, timedelta
from api_client import CoinGeckoAPIClient
from data_manager import DataManager

class Exporter:
    def __init__(self, api_client: CoinGeckoAPIClient, data_manager: DataManager):
        self.api_client = api_client
        self.data_manager = data_manager

    def export_portfolio_to_csv(self, file_path='portfolio.csv'):
        """Export the current portfolio to a CSV file."""
        try:
            portfolio = self.data_manager.get_portfolio()
            with open(file_path, mode='w', newline='') as file:
                writer = csv.writer(file)
                writer.writerow(['Cryptocurrency', 'Amount', 'Current Price (USD)', 'Total Value (USD)'])

                for crypto in portfolio:
                    crypto_name = crypto[1]
                    if crypto_name:
                        current_price = self.api_client.get_current_price(crypto_name)
                        if current_price is not None:
                            total_value = crypto['amount'] * current_price
                            writer.writerow([crypto_name, crypto['amount'], current_price, total_value])

            print(f"Portfolio successfully exported to {file_path}")
        except Exception as e:
            print(f"Error exporting portfolio to CSV: {e}")

    def export_historical_prices_to_csv(self, crypto_id, start_date, end_date, file_path='historical_prices.csv'):
        """Export historical prices of a cryptocurrency to a CSV file."""
        try:
            start_date_obj = datetime.strptime(start_date, '%Y-%m-%d')
            end_date_obj = datetime.strptime(end_date, '%Y-%m-%d')
            current_date = start_date_obj

            with open(file_path, mode='w', newline='') as file:
                writer = csv.writer(file)
                writer.writerow(['Date', 'Price (USD)'])

                while current_date <= end_date_obj:
                    date_str = current_date.strftime('%d-%m-%Y')
                    price = self.api_client.get_historical_price(crypto_id, date_str)
                    if price is not None:
                        writer.writerow([current_date.strftime('%Y-%m-%d'), price])
                    current_date += timedelta(days=1)

            print(f"Historical prices successfully exported to {file_path}")
        except Exception as e:
            print(f"Error exporting historical prices to CSV: {e}")
```

### `requirements.txt`
```
PyQt6
requests
notify2
matplotlib
```

### `README.md`
```markdown
git clone <repository-url>
   cd crypto-portfolio-dashboard
```

### `.env.example`
```example
# .env.example

# API configuration
COINGECKO_API_BASE_URL=https://api.coingecko.com/api/v3

# Database configuration
DATABASE_PATH=./crypto_portfolio.db

# Notification settings
NOTIFICATION_APP_NAME=Crypto Portfolio Dashboard

# Export settings
EXPORT_PORTFOLIO_CSV_PATH=./portfolio.csv
EXPORT_HISTORICAL_PRICES_CSV_PATH=./historical_prices.csv

# UI settings
UI_WINDOW_TITLE=Crypto Portfolio Dashboard
UI_WINDOW_GEOMETRY=800x600
```

### `install.sh`
```bash
#!/bin/bash

# This script installs the necessary system dependencies for the Crypto Portfolio Dashboard application.

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Update package lists
if command_exists apt; then
    sudo apt update
elif command_exists dnf; then
    sudo dnf check-update
else
    echo "Neither apt nor dnf package manager found. Exiting."
    exit 1
fi

# Install dependencies
install_dependencies() {
    if command_exists apt; then
        sudo apt install -y python3 python3-pip python3-venv libnotify-bin
    elif command_exists dnf; then
        sudo dnf install -y python3 python3-pip python3-virtualenv libnotify
    else
        echo "Neither apt nor dnf package manager found. Exiting."
        exit 1
    fi
}

# Install Python packages
install_python_packages() {
    python3 -m pip install --upgrade pip
    python3 -m pip install -r requirements.txt
}

# Execute installation functions
install_dependencies
install_python_packages

echo "Installation completed successfully."
```

### `crypto_portfolio_dashboard.desktop`
```desktop
[Desktop Entry]
Version=1.0
Type=Application
Name=Crypto Portfolio Dashboard
Comment=Manage and track your cryptocurrency portfolio
Exec=python3 /path/to/your/application/main.py
Icon=/path/to/your/application/icon.png
Terminal=false
Categories=Finance;Cryptocurrency;
StartupNotify=true
```

### `flatpak_manifest.json`
```json
{
    "app-id": "com.example.CryptoPortfolioDashboard",
    "runtime": "org.freedesktop.Platform",
    "runtime-version": "21.08",
    "sdk": "org.freedesktop.Sdk",
    "command": "main.py",
    "modules": [
        {
            "name": "python3",
            "buildsystem": "simple",
            "build-commands": [
                "pip3 install --no-index --find-links='file://${PWD}' --requirement=requirements.txt"
            ],
            "sources": [
                {
                    "type": "archive",
                    "url": "https://www.python.org/ftp/python/3.9.7/Python-3.9.7.tar.xz",
                    "sha256": "0d78f5e8e7b8e8f8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8"
                },
                {
                    "type": "file",
                    "path": "requirements.txt"
                }
            ]
        },
        {
            "name": "CryptoPortfolioDashboard",
            "buildsystem": "simple",
            "build-commands": [
                "install -D main.py /app/main.py",
                "install -D ui.py /app/ui.py",
                "install -D data_manager.py /app/data_manager.py",
                "install -D api_client.py /app/api_client.py",
                "install -D notification_manager.py /app/notification_manager.py",
                "install -D exporter.py /app/exporter.py",
                "install -D crypto_portfolio_dashboard.desktop /app/share/applications/crypto_portfolio_dashboard.desktop"
            ],
            "sources": [
                {
                    "type": "file",
                    "path": "main.py"
                },
                {
                    "type": "file",
                    "path": "ui.py"
                },
                {
                    "type": "file",
                    "path": "data_manager.py"
                },
                {
                    "type": "file",
                    "path": "api_client.py"
                },
                {
                    "type": "file",
                    "path": "notification_manager.py"
                },
                {
                    "type": "file",
                    "path": "exporter.py"
                },
                {
                    "type": "file",
                    "path": "crypto_portfolio_dashboard.desktop"
                }
            ]
        }
    ]
}
```

---
*End of Consolidated Package â€” crypto_portfolio_dashboard*